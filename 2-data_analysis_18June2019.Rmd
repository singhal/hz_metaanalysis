---
title: "Data Analysis for HZ"
author: "sonal and jay"
date: "January 4, 2018; updated 11 July 18"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE, fig.width = 3, fig.height = 2)
knitr::opts_knit$set(root.dir = '~/Dropbox/hz_metaanalysis/data_analysis/')

library(cowplot)
library(lme4)
library(MuMIn)
library(r2glmm)
library(dplyr)
library(glmulti)
```

## Load functions

```{r}
# https://stackoverflow.com/questions/2602583/geometric-mean-is-there-a-built-in
gm_mean = function(x, na.rm=TRUE){
  exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x))
}

sub_summarize <- function(model, low_model) {
    # make a model summary
    # structure, log likeli, aicc, r2GLMM - fixed, r2glmm - condition
    name = as.character(model@call)[2]
    d = summary(model)$logLik
    lnl = round(as.numeric(gsub('^.*df=', '', d)), 1)
    df = attr(d, 'df')
    aic = round(AICc(model), 1)
    daic = AICc(model) -  AICc(low_model)
    daic = round(daic, 3)
    fixed_r2 = round(as.numeric(r.squaredGLMM(model)[1]), 3)
    cond_r2 = round(as.numeric(r.squaredGLMM(model)[2]), 3)
    res = list(name, df, lnl, aic, daic, fixed_r2, cond_r2)
    names(res) = c("formula", "d.f.", "log like", "AICc", "dAIC", "r2 fixed", "r2 cond")
    return(res)
}

summarize_model <- function(models) {
  aiccs = unlist(lapply(models, AICc))
  low = which(aiccs == min(aiccs))
  
  res = sapply(models, sub_summarize, models[[low]])
  res = t(res)
  
  modavg1 <- model.avg(models)
  modavg2 = summary(modavg1)
  # factors
  col1 = dimnames(modavg2$coefmat.full)[[1]]
  # coef
  col2 = round(modavg2$coefmat.full[, 1], 3)
  # se
  col3 = round(modavg2$coefmat.full[, 3], 3)
  # rel imp
  relimp = round(as.vector(modavg2$importance), 3)
  names(relimp) = names(modavg2$importance) 

  res2 = data.frame(coef = col2, coef_se = col3)
  res3 = data.frame(terms = names(relimp), RI=relimp)  
  return(list(res, res2, res3))
}


summarize_lm_sub <- function(model) {
  fmla = as.character(model$call)[2]
  aic = round(AICc(model), 1)
  r2 = round(summary(model)$adj.r.squared, 3)
  df =  paste(summary(model)$df[1:2], collapse=",")
  res = list(fmla, df, aic, r2)
  return(res)
}

summarize_lm <- function(models) {
  res = as.data.frame(t(sapply(models, summarize_lm_sub)))
  
  names(res) = c("formula", "df", "AICc", "adj. r-squared")
  res$rel_likelihood = round(exp((min(unlist(res$AICc)) - unlist(res$AICc)) / 2), 3)
  res <- apply(res,2,as.character)
  
  # model averaging 1
  modavg1 = model.avg(models)
  modavg2 = summary(modavg1)
  # factors
  col1 = dimnames(modavg2$coefmat.full)[[1]]
  # coef
  col2 = modavg2$coefmat.full[, 1]
  # se
  col3 = modavg2$coefmat.full[, 3]
  res2 = data.frame(terms = col1, coef = col2, coef_se = col3)
  
  # rel imp
  relimp = data.frame(modavg2$importance)

  return(list(res, res2, relimp))
}

glmulti_mod_sel_table <- function(glmulti_obj, howmany = "all"){
    if(is.integer(howmany)){
      howmany = howmany
    }
    else if(howmany == "all"){
      howmany = length(summary(glmulti_obj)$icvalues)
    }
    mod_sel_table = weightable(glmulti_obj)[1:as.integer(howmany),]
    mod_sel_table$adj.r2 <- rep(NA, howmany)
    mod_sel_table$resid.df <- rep(NA, howmany)
    for (i in 1:howmany){
      i <- as.character(i)
      summ <- eval(parse(text = paste("summary", "(", deparse(substitute(glmulti_obj)), "@objects[[", i, "]]", ")", sep = "")))
      mod_sel_table$adj.r2[as.integer(i)] <- summ$adj.r.squared
      mod_sel_table$resid.df[as.integer(i)] <- summ$df[2]
    }
    return(mod_sel_table)
}
```

## Load Data 
```{r}
setwd("~/Dropbox/hz_metaanalysis/data_analysis/")
outdir = '~/Dropbox/hz_metaanalysis/manuscript/figures/'
orig = read.csv("cleaned_combined_data-Jul-22-19.csv", stringsAsFactors = F, na.strings = c("", "NA"))

# add in HWI data
hwi = read.csv("bird_HWIs.csv", stringsAsFactors = F, na.strings = c("", "NA"))
orig$HWI = hwi[match(orig$SystemID, hwi$SystemID), 'HWI_mean']
orig$disp_or_HWI = !is.na(orig$dispersal) | !is.na(orig$HWI)

## All systems have either dispersal estimates or HWI
num1 = length(unique(orig$SystemID))
x = orig[orig$disp_or_HWI == TRUE, ]
x = x[complete.cases(x$mean_dist), ]
x = x[complete.cases(x$width), ]
num2 = length(unique(x$SystemID))
dropped = unique(orig[!orig$SystemID %in% x$SystemID, c("SystemID", "Taxon1", "Taxon2")])
```
Before cleaning, there were `r num1` studies, and, after, `r num2`. A few studies were dropped because of missing mtDNA distance.

## Transform, Log, Center data etc.
```{r}
s = x[, c(names(x)[1:40], names(x)[56])]
s = unique(s)

s$log_dispersal = scale(log(s$dispersal))
s$log_dispersal_ind = scale(log(s$dispersal_only_ind))
s$log_HWI = scale(log(s$HWI))
s$log_dist = scale(log(s$mean_dist))
s$log_max_dist = scale(log(s$max_dist))
s$log_mean_nDNA = scale(log(s$mean_nDNA))
s$log_max_nDNA = scale(log(s$max_nDNA))

j = tapply(x$width, x$SystemID, FUN = gm_mean)
j = as.data.frame(j)
j$SystemID = rownames(j)
colnames(j) = c("gm_mean_width", "SystemID")
s = merge(s, j, by = "SystemID")
```

Visalizing the distributions of predictor variables
```{r, echo=F}
ggplot(s, aes(log_dist)) + geom_histogram(binwidth=0.5) + xlab("scaled mtDNA dist")
ggplot(s, aes(log_mean_nDNA)) + geom_histogram(binwidth=0.5) + xlab("scaled nDNA dist")
cor.test(s$log_mean_nDNA, s$log_dist)
mtnucfig = ggplot(s, aes(log_mean_nDNA, log_dist)) + geom_point() + xlab("log(nDNA distance)") + ylab("log(mtDNA distance)")
save_plot(paste(outdir, 'nuclear_mitochondrial_distance.png', sep=""), mtnucfig, base_aspect_ratio = 1.3, base_height = 3)

ggplot(s, aes(log_dispersal)) + geom_histogram(binwidth=0.5) + xlab("scaled dispersal")
ggplot(s, aes(log_dispersal_ind)) + geom_histogram(binwidth=0.5) + xlab("scaled dispersal")
ggplot(s, aes(log_HWI)) + geom_histogram(binwidth=0.5) + xlab("scaled HWI")
```


## Check for outliers
There are two mtDNA distances that are quite divergent, _Hyla arborea x orientalis_ and _Mytilus edulis x trossulus_. Will double check them both as those distances were calculated using NCBI data. (They seemed okay.)

```{r, echo=F}
ggplot(s, aes(mean_dist)) + geom_histogram(binwidth=0.005) + xlab("mtDNA dist")
```

There are a few outliers in the dispersal data ... all birds. The dispersal estimate for Colaptes auratus has been applied to other partially migratory North American woodpecker hybrid zones, so there are several hybrid zones assigned RMS dispersal rates of 100 km/sqrt(gen). There are `r nrow(s[s$dispersal < 0.1, ])` taxa that exhibit very low dispersal rates (< 0.1), and these do not appear to be outliers.

```{r, echo=F}
ggplot(s, aes(dispersal)) + geom_histogram(binwidth=4) + xlab("dispersal")
```

## Some basic descriptive graphs
```{r}
a = ggplot(s, aes(critter)) + geom_bar() +  coord_flip() + xlab("taxonomic group")
```

The data set is pretty balanced across taxonomic groups, though not that many studies in fish. (Most fish studies I found exhibited more mosaic patterns, interestingly.)

```{r}
b = ggplot(s, aes(location)) + geom_bar() +  coord_flip() 
ab = plot_grid(a, b, labels = c("A", "B"), nrow = 1, align = "h")
save_plot(paste(outdir, 'study_details.png', sep=""), ab, ncol = 2, nrow = 1, base_aspect_ratio = 1.3, base_width = 5)
```

The dataset is heavily biased towards temperate regions -- but, does that mean we are also picking up on a lot of Holocene range expansions following late-Pleistocene divergence (i.e., Hewitt 1999)? The genetic distances don't seem to suggest so (i.e. there's a wide range of values, with many large distances).

There is quite a range in dispersal patterns, much of which is reflected in taxonomic groups.
```{r}
a = ggplot(s, aes(critter, log_dispersal)) + geom_boxplot() + coord_flip() + ylab("log(dispersal)") + xlab("taxonomic group")
save_plot(paste(outdir, 'dispersal_by_taxonomic_group.png', sep=""), a, base_aspect_ratio = 1.3, base_height = 3)
dis_taxon = lm(s$log_dispersal ~ s$critter)
```


```{r}
clno=data.frame(table(x$SystemID))
clno$num_types = unlist(lapply(split(x, x$SystemID), function(df) {length(unique(df$type))}))
a = ggplot(clno, aes(Freq)) + geom_histogram(binwidth=0.2) + xlab("number of clines") + scale_x_log10()
b = ggplot(clno, aes(num_types)) + geom_histogram(binwidth=1) + xlab("number of cline types")
t = unique(x[,c("type", "SystemID")])
c = ggplot(t, aes(type)) + geom_bar() +  coord_flip() + xlab("number of studies")

clgraph = plot_grid(a, b, c, labels = c("A", "B", "C"), nrow = 1, align = "h")
save_plot(paste(outdir, 'cline_data.png', sep=""), clgraph,
          ncol = 3, nrow = 1, base_width = 5, base_aspect_ratio = 1.3
          )
```


## Bird HWI data
```{r, echo=F}
HWI_disp_corr_data <- s[which(!is.na(s$log_dispersal) & !is.na(s$log_HWI)),]
HWI_disp_corr_data$outlier <- ifelse(HWI_disp_corr_data$log_dispersal > -1, FALSE, TRUE)
a = ggplot(HWI_disp_corr_data, aes(log_HWI, log_dispersal)) + geom_point(aes(color = outlier)) + xlab("log(HWI)") + ylab("log(dispersal)") + scale_color_manual(values=c("black", "red")) + theme(legend.position="none")
phydist = read.csv("bird_phydist.csv", stringsAsFactors = F)
phydist$type = ifelse(phydist$Burleigh > 15, "outlier", "ok")
b = ggplot(phydist, aes(Burleigh, mtDNA_dist)) + geom_point(aes(color = type)) + xlab("phylogenetic distance") + ylab("mtDNA distance") + scale_color_manual(values=c("black", "red")) + theme(legend.position="none")

corr1 = cor.test(HWI_disp_corr_data$log_HWI, HWI_disp_corr_data$log_dispersal)
HWI_outlier_removed <- HWI_disp_corr_data[which(HWI_disp_corr_data$Taxon1 != "Sula nebouxii"),]
corr1
corr1a = cor.test(HWI_outlier_removed$log_HWI, HWI_outlier_removed$log_dispersal)
corr1a

##examine correlation of HWI and dispersal distance while controlling for phylogeny

library(ape)
library(phylolm)
phy <- read.tree("bigbird_new_BLs.tre")
j<-lapply(phy$tip.label, function(x) strsplit(x, split="_"))
tippies<-unlist(lapply(j, function(x) paste(x[[1]][3],x[[1]][4], sep=" ")))
phy$tip.label <- tippies
HWI_phylo_tax <- read.csv("taxonomic_reconciliation_HWI_disp.csv")
HWI_phylo_tax$hz_name <- as.character(HWI_phylo_tax$hz_name)
HWI_phylo_tax$burleigh_name <- as.character(HWI_phylo_tax$burleigh_name)
HWI_disp_corr_data$phylo_name <- HWI_disp_corr_data$Taxon1

for(i in 1:length(HWI_disp_corr_data$phylo_name)){
 if (HWI_disp_corr_data$phylo_name[i] %in% HWI_phylo_tax$hz_name){
   HWI_disp_corr_data$phylo_name[i] <- HWI_phylo_tax$burleigh_name[which(HWI_phylo_tax$hz_name == HWI_disp_corr_data$phylo_name[i])]
 }
}

##Remove doubled-up species for phylogenetic analysis
##Setophaga auduboni N, Sphyrapicus ruber (better HWI sampling for Sphyrapicus varius than Sphyrapicus nuchalis, so remove based on Taxon2 == Sphyrapicus nuchalis), Hirundo rustica tytleri

HWI_phylo_test <- HWI_disp_corr_data[which(!HWI_disp_corr_data$phylo_name %in% c("Setophaga auduboni N", "Hirundo rustica tytleri")),]
HWI_phylo_test <- HWI_phylo_test[which(HWI_phylo_test$Taxon2 != "Sphyrapicus nuchalis"),]

##Must remove species without an independent dispersal estimate. Remove: Baeolophus bicolor, Dinopium shorii, Geothlypis tolmiei, Pheucticus melanocephalus, Sphyrapicus ruber, Setophaga occidentalis
HWI_phylo_test <- HWI_phylo_test[which(!HWI_phylo_test$phylo_name %in% c("Baeolophus atricristatus", "Dinopium shorii", "Geothlypis tolmiei", "Pheucticus melanocephalus", "Sphyrapicus ruber", "Setophaga occidentalis")),]

##n = 24 for phylogenetic correlation
phy <- drop.tip(phy, tip = phy$tip.label[which(!phy$tip.label %in% HWI_phylo_test$phylo_name)])
rownames(HWI_phylo_test) <- HWI_phylo_test$phylo_name
phy_corr1 <- phylolm(log_dispersal ~ log_HWI, data = HWI_phylo_test, phy = phy, model = c("OUrandomRoot"))
##This OU analysis approaches BM
sink("phylogenetic_disp_dist_by_HWI.txt")
print(summary(phy_corr1))
sink()

corr2 = cor.test(phydist$Burleigh, phydist$mtDNA_dist)
phydist_no = phydist[phydist$Taxon1 != 'Baeolophus atricristatus', ]
corr2a = cor.test(phydist_no$Burleigh, phydist_no$mtDNA_dist) 
  
bird = plot_grid(a, b, labels = c("A", "B"), nrow = 1, align = "h")
save_plot(paste(outdir, 'bird_proxies.png', sep=""), bird,
          ncol = 2, nrow = 1, base_height = 3, base_aspect_ratio = 1.2
          )
```

Dispersal and HWI are strongly correlated as one would hope, especially after removing the outlier (Sula). Phylogenetic distance and mtDNA distance are too, if you remove the one obvious outlier (Baeolophus).


```{r}
a = ggplot(s, aes(log_dispersal, log_dist)) + geom_point() + xlab("log(dispersal)") + ylab("log(mtDNA distance)")
cortest = cor.test(s$log_dispersal, s$log_dist)
save_plot(paste(outdir, 'mtDNAdist_dispersal.png', sep=""), a, base_aspect_ratio = 1.3, base_width = 4)
```

We have reason to believe that dispersal and mtDNA distance are correlated ... and they are, albeit weakly.
What is the distribution of cline widths for hybrid zones where we measured many clines?

```{r}
high = x %>% group_by(SystemID) %>% summarise(cts = n()) %>% ungroup() %>% filter(cts >= 10) 
print(length(unique(high$SystemID)))
high = x %>% filter(SystemID %in% high$SystemID)
means =  high %>% group_by(Taxon1) %>% summarise(gm_mean_width = gm_mean(width))

hiplot = ggplot(high, aes(width)) + geom_histogram() + 
  geom_vline(data = means, aes(xintercept = gm_mean_width, color = "red")) +
  facet_wrap(~Taxon1, scales = "free") + theme(legend.position="none",
                                               strip.text = element_text(size=12))
save_plot(paste(outdir, 'cline_width_distribution.png', sep=""), hiplot, base_width = 12, base_height = 8)
```

```{r}
png(filename = "max_vs_mean_mtdna_dist.png")
plot(s$mean_dist, s$max_dist, abline(a = 0, b = 1), xlab = "mean dist", ylab = "max dist")
dev.off()
png(filename = "med_vs_mean_mtdna_dist.png")
plot(s$mean_dist, s$median_dist, abline(a = 0, b = 1), xlab = "mean dist", ylab = "median dist")
dev.off()

png(filename = "max_vs_mean_nucdna_dist.png")
plot(s$mean_nDNA, s$max_nDNA, abline(a = 0, b = 1), xlab = "mean nuc dist", ylab = "max nuc dist")
dev.off()

```


## Main Analyses
## 1. Nuclear + mt DNA analyses
## 2. Most-inclusive sampling analyses, using mtDNA distances but no nuclear distances 
## 3. Clade-specific analyses
### Response variable is geometric mean of clines for each hybrid zones pair
```{r}
s$log_width = log(s$gm_mean_width)
```
## 1. Analyses including nuclear DNA
```{r}
nucDNA_models <- glmulti(y = "log_width", xr = c("log_dispersal_ind", "log_dist", "log_mean_nDNA", "critter"), data = s, level = 2, fitfunction = lm, marginality = TRUE, crit = "aicc", confsetsize = 20)

mod_sel <- glmulti_mod_sel_table(nucDNA_models, 10)
write.csv(mod_sel, paste(outdir, "nucDNA_model_selection.csv", sep=""), row.names = F)
nucDNA_model_coefs <- coef(nucDNA_models, select = 0.95)
write.csv(nucDNA_model_coefs, paste(outdir, "nucDNA_model_coefs.csv", sep=""), row.names = T)
```
## 2. Most-inclusive analyses, using mtDNA distances but no nuclear distances
```{r}
mtDNA_models <- glmulti(y = "log_width", xr = c("log_dispersal_ind", "log_dist", "critter"), data = s, level = 2, fitfunction = lm, marginality = TRUE, crit = "aicc")
mod_sel <- glmulti_mod_sel_table(mtDNA_models)
write.csv(mod_sel, paste(outdir, "mtDNA_model_selection.csv", sep=""), row.names = F)
mtDNA_model_coefs <- coef(mtDNA_models, select = 0.95)
write.csv(mtDNA_model_coefs, paste(outdir, "mtDNA_model_coefs.csv", sep=""), row.names = T)
```

## 3. Clade-specific analyses

```{r}
s1 <- s[which(!s$critter == "fish"),]
s1 <- s1[which(!s1$critter == "other invertebrates"),]

s1 <- s1[complete.cases(s1$log_dispersal_ind),]

t = split(s1, s1$critter)
taxares = data.frame(critter=names(t), 
                 num_studies=unlist(lapply(t, nrow)), 
                 best_model=rep(NA, length(t)), 
                 rsq=rep(NA, length(t)), 
                 dispersal=rep(NA, length(t)), 
                 mtDNA_dist=rep(NA, length(t)), 
                 interaction = rep(NA, length(t)),
                 dispersalRI =rep(NA, length(t)), 
                 mtDNA_distRI =rep(NA, length(t)), 
                 interactionRI = rep(NA, length(t)))

coefres = data.frame(critter = rep(NA, 2 * length(t)),
                     variable = rep(NA, 2 * length(t)),
                     coef = rep(NA, 2 * length(t)),
                     intercept = rep(NA, 2 * length(t)))

physig = vector('list', length(t))

for (i in 1:length(t)) {
  ms <- glmulti(y = "log_width", xr = c("log_dispersal_ind", "log_dist"), data = t[[i]], level = 2, fitfunction = lm, marginality = TRUE, crit = "aicc")
  mod_sel <- glmulti_mod_sel_table(ms)
  coef_ests <- coef(ms)
  best_model = summary(ms)$bestmodel
  coefbest <- ms@objects[[1]]$coefficients
  coefres[2 * i - 1, 'critter'] = names(t)[i]
  coefres[2 * i, 'critter'] = names(t)[i]
  coefres[2 * i - 1, 'intercept'] = coefbest[1]
  coefres[2 * i, 'intercept'] = coefbest[1]
  coefres[2 * i - 1, 'variable'] = 'log_dist'
  coefres[2 * i, 'variable'] = 'log_dispersal_ind'
  if (length(which(names(coefbest) == "log_dist")) > 0) {
    coefres[2 * i - 1, 'coef'] = coefbest[which(names(coefbest) == "log_dist")]
  }
  if (length(which(names(coefbest) == "log_dispersal_ind")) > 0) {
    coefres[2 * i, 'coef'] = coefbest[which(names(coefbest) == "log_dispersal_ind")]
  }
  se_combine <- function(x) {
    return(paste(x[1], " (SE=", x[2], ")", sep=""))
  }
  taxares[i , "best_model"] = summary(ms)$bestmodel
  taxares[i , "rsq"] = summary(ms@objects[[1]])$adj.r.squared
  if (length(which(names(coefbest) == "log_dispersal_ind")) > 0) {
    taxares[i , "dispersal"] = se_combine(round(coef(summary(ms@objects[[1]]))["log_dispersal_ind", 1:2], 2))
  }
  if (length(which(names(coefbest) == "log_dist")) > 0) {
    taxares[i , "mtDNA_dist"] = se_combine(round(coef(summary(ms@objects[[1]]))["log_dist", 1:2], 2))
  }
  if (length(which(names(coefbest) == "log_dispersal_ind:log_dist")) > 0) {
    taxares[i , "interaction"] = se_combine(round(coef(summary(ms@objects[[1]]))["log_dispersal_ind:log_dist", 1:2], 2))
  }
  taxares[i , "dispersalRI"] = round(coef_ests["log_dispersal_ind","Importance"])
  taxares[i , "mtDNA_distRI"] = round(coef_ests["log_dist","Importance"])
  taxares[i , "interactionRI"] = round(coef_ests["log_dispersal_ind:log_dist", "Importance"])
}



for (i in 1:length(t)) {
  full_interaction = lm(log_width ~ log_dispersal_ind * log_dist, data = t[[i]])
  no_interaction = lm(log_width ~ log_dispersal_ind + log_dist, data = t[[i]])
  dispersal_only = lm(log_width ~ log_dispersal_ind, data = t[[i]])
  distance_only = lm(log_width ~ log_dist, data = t[[i]])
  intercept_only = lm(log_width ~ 1, data = t[[i]])
  ms <- list(full_interaction, no_interaction, dispersal_only, distance_only, intercept_only)
  names(ms) = c("full_interaction", "no_interaction", "dispersal_only", "distance_only", "intercept_only")

  res = summarize_lm(ms)
  best = which(as.numeric(res[[1]][, 3]) == min(as.numeric(res[[1]][, 3])))
  
  best_model = ms[[best]]
  coefbest = coef(best_model)
  coefres[2 * i - 1, 'critter'] = names(t)[i]
  coefres[2 * i, 'critter'] = names(t)[i]
  coefres[2 * i - 1, 'intercept'] = coef(best_model)[1]
  coefres[2 * i, 'intercept'] = coef(best_model)[1]
  coefres[2 * i - 1, 'variable'] = 'log_dist'
  coefres[2 * i, 'variable'] = 'log_dispersal_ind'
  if (length(which(names(coefbest) == "log_dist")) > 0) {
    coefres[2 * i - 1, 'coef'] = coefbest[which(names(coefbest) == "log_dist")]
  }
  if (length(which(names(coefbest) == "log_dispersal_ind")) > 0) {
    coefres[2 * i, 'coef'] = coefbest[which(names(coefbest) == "log_dispersal_ind")]
  }
  se_combine <- function(x) {
    return(paste(x[1], " (SE=", x[2], ")", sep=""))
  }
  
  taxares[i , "best_model"] = res[[1]][best, 1]
  taxares[i , "rsq"] = res[[1]][best, 4]
  taxares[i , "dispersal"] = se_combine(round(res[[2]][2, c(2,3)], 2))
  taxares[i , "mtDNA_dist"] = se_combine(round(res[[2]][3, c(2,3)], 2))
  taxares[i , "interaction"] = se_combine(round(res[[2]][4, c(2,3)], 2))
  taxares[i , "dispersalRI"] = round(res[[3]][1, 1], 3)
  taxares[i , "mtDNA_distRI"] = round(res[[3]][2, 1], 3)
  taxares[i , "interactionRI"] = round(res[[3]][3, 1], 3)

  # test phy signal
  phyres = cbind(t[[i]], res = best_model$residuals)
  phyres$tip_taxa = tips[match(phyres$Taxon1, tips$X), "tip_taxa"]
  t2 = drop.tip(t1, setdiff(t1$tip.label, phyres$tip_taxa))
  phyres1 = phyres[phyres$tip_taxa %in% t1$tip.label, ]
  # have multiple studies to the same tip, for now, just average residuals
  phyres2 = phyres1 %>% group_by(tip_taxa) %>%
              summarise(res = mean(res)) %>% ungroup()
  physig[[i]] = phylosig(t2, pull(phyres2[match(t2$tip.label, phyres2$tip_taxa),       "res"]), method="lambda", test = T)
}

knitr::kable(taxares)
write.csv(taxares, paste(outdir, "taxon_results.csv", sep=""), row.names = T)
```


##Sensitivity analyses
#4. Max distances instead of min in nuclear + mtDNA analyses
#5. Max mtDNA distance in mtDNA only analysis
#6. Hybrid index model with nuclear DNA
#7. Hybrid index model with mtDNA only
#8. Best dispersal estimates

##Max distances instead of min in nuclear + mtDNA analyses
```{r}
nucDNA_models_max <- glmulti(y = "log_width", xr = c("log_dispersal_ind", "log_max_dist", "log_max_nDNA", "critter"), data = s, level = 2, fitfunction = lm, marginality = TRUE, crit = "aicc", confsetsize = 20)

mod_sel <- glmulti_mod_sel_table(nucDNA_models_max, 10)
write.csv(mod_sel, paste(outdir, "nucDNA_max_model_selection.csv", sep=""), row.names = F)
nucDNA_max_model_coefs <- coef(nucDNA_models_max, select = 0.95)
write.csv(nucDNA_max_model_coefs, paste(outdir, "nucDNA_max_model_coefs.csv", sep=""), row.names = T)
```

##Max mtDNA distance in mtDNA only analysis
```{r}
mtDNA_max_models <- glmulti(y = "log_width", xr = c("log_dispersal_ind", "log_max_dist", "critter"), data = s, level = 2, fitfunction = lm, marginality = TRUE, crit = "aicc")
mod_sel <- glmulti_mod_sel_table(mtDNA_max_models)
write.csv(mod_sel, paste(outdir, "mtDNA_max_model_selection.csv", sep=""), row.names = F)
mtDNA_max_model_coefs <- coef(mtDNA_max_models, select = 0.95)
write.csv(mtDNA_max_model_coefs, paste(outdir, "mtDNA_max_model_coefs.csv", sep=""), row.names = T)
```

## HI 
#Hybrid index models - including nDNA and mtDNA, and excluding nDNA (mtDNA only)
```{r}
x1 = x
x1$clineID = seq(1, nrow(x1))
# select all quantitative clines
hi = x1 %>% filter(type %in% c("nuclear", "karyotype", "sexlinked") | biallelic_or_quantitative == 'quantitative')
hi$num_markers2 = as.numeric(hi$num_markers)

# fill in some missing num_markers info
keep = c("HI", "q-score", "hybrid index", "allozymes", "multilocus allozyme cline", "q-score for microsats", "New Hybrids hybrid index of AFLPs", "1000 randomly selected markers", "hybrid index", "Structure q-value", "structure q-score", "SNPs", "genomic ancestry")
hi[hi$details %in% keep, "num_markers2"] = 10

# these are all hybrid index presumably because based on more than one marker
hi = hi %>% filter(num_markers2 > 1 |  biallelic_or_quantitative == 'quantitative')

# double check the details to see if they look about right
hi[which(hi$num_markers2 > 1), c("type", "details")]
# and they do -- one karyotype that I'm not sure belongs, but otherwise PCA, q-score, etc.

# first compare hybrid index estimate of cline width to all other estimates
hi2 = x1 %>% filter(SystemID %in% hi$SystemID) %>% filter(!clineID %in% hi$clineID)
# only do genetic data because all phenotypes are quantitative traits
hi2 = hi2 %>% filter(type %in% c("karyotype", "mtDNA", "nuclear", "sexlinked"))

hi = hi %>% group_by(SystemID) %>% summarise(gm_mean_hi_width = gm_mean(width)) %>% ungroup()
hi2 = hi2 %>% group_by(SystemID) %>% summarise(gm_mean_width = gm_mean(width)) %>% ungroup()
hi3 = inner_join(hi, hi2)
hybindplot = ggplot(hi3, aes(gm_mean_width, gm_mean_hi_width)) + geom_point() + xlab("width, geometric mean") + ylab("hybrid index width") + scale_x_log10() + scale_y_log10() + geom_abline(slope = 1, intercept = 0, col = "red")
save_plot(paste(outdir, "hybrid_index_vs_geometricmean.png", sep=""), hybindplot)

cor.test(hi3$gm_mean_hi_width, hi3$gm_mean_width, method ="spearman")
```

```{r}
hi = inner_join(s, hi)
hi$log_hi_width = log(hi$gm_mean_hi_width)
hi_nDNA = hi %>% filter(complete.cases(log_dispersal_ind) & complete.cases(log_dist) & complete.cases(log_mean_nDNA))
## n = 55
HI_nDNA_models <- glmulti(y = "log_hi_width", xr = c("log_dispersal_ind", "log_dist", "log_mean_nDNA", "critter"), data = hi_nDNA, level = 2, fitfunction = lm, marginality = TRUE, crit = "aicc", confsetsize = 20)
mod_sel <- glmulti_mod_sel_table(HI_nDNA_models, 10)
write.csv(mod_sel, paste(outdir, "HI_nDNA_model_selection.csv", sep=""), row.names = F)
HI_nDNA_model_coefs <- coef(HI_nDNA_models, select = 0.95)
write.csv(HI_nDNA_model_coefs, paste(outdir, "HI_nDNA_model_coefs.csv", sep=""), row.names = T)

hi_mtDNA = hi %>% filter(complete.cases(log_dispersal_ind) & complete.cases(log_dist))
## n = 87
HI_mtDNA_models <- glmulti(y = "log_hi_width", xr = c("log_dispersal_ind", "log_dist", "critter"), data = hi_mtDNA, level = 2, fitfunction = lm, marginality = TRUE, crit = "aicc", confsetsize = 20)
mod_sel <- glmulti_mod_sel_table(HI_mtDNA_models, 10)
write.csv(mod_sel, paste(outdir, "HI_mtDNA_model_selection.csv", sep=""), row.names = F)
HI_mtDNA_model_coefs <- coef(HI_mtDNA_models, select = 0.95)
write.csv(HI_mtDNA_model_coefs, paste(outdir, "HI_mtDNA_model_coefs.csv", sep=""), row.names = T)

```


##Figure X

```{r fig.width = 7, fig.asp = .62}
plt1 = ggplot(xy, aes(log_dispersal_ind, log_width)) + 
  geom_point(pch=16, aes(color=critter)) + 
  xlab("log(dispersal)") + ylab("log(cline width)") + 
  scale_color_manual(values = cols, name="taxonomic group") 
plt2 = ggplot(xy, aes(log_dist, log_width)) + 
  geom_point(pch=16, aes(color=critter)) + 
  xlab("log(mtDNA distance)") + ylab("log(cline width)") + 
  scale_color_manual(values = cols, name="taxonomic group")

# build plot
prow <- plot_grid(
  plt1 + theme(legend.position="none"),
  plt2 + theme(legend.position="none"),
  align = 'vh',
  labels = c("A", "B"),
  hjust = -1,
  nrow = 1
)
legend <- get_legend(plt1)
p <- plot_grid(prow, legend, rel_widths = c(2, .6))

save_plot(paste(outdir, 'mean_data.png', sep=""), p,
          nrow = 1, base_height = 3, base_width = 8
          )
```

Check if residuals have phylogenetic structure.

```{r}
t = read.tree("~/Desktop/Metazoa_species.nwk")
phyres = cbind(xy, m9res = m9y$residuals, m12res = m12y$residuals)
tips = read.csv("~/Desktop/tips.csv", stringsAsFactors = F)

phyres$tip_taxa = tips[match(phyres$Taxon1, tips$X), "tip_taxa"]

t1 = drop.tip(t, setdiff(t$tip.label, phyres$tip_taxa))
phyres1 = phyres[phyres$tip_taxa %in% t1$tip.label, ]
# have multiple studies to the same tip, for now, just average residuals
phyres2 = phyres1 %>% group_by(tip_taxa) %>% 
              summarise(m9res = mean(m9res), 
                        m12res = mean(m12res), 
                        dispersal = mean(log_dispersal_ind),
                        width = mean(log_width),
                        dist = mean(log_dist),
                        critter = unique(critter)) %>% ungroup()

# test if phylogeny kinda works
phylosig(t1, pull(phyres2[match(t1$tip.label, phyres2$tip_taxa), "dispersal"]), method="lambda", test = T)
# see strong phy signal in dispersal, as we would expect

phylosig(t1, pull(phyres2[match(t1$tip.label, phyres2$tip_taxa), "m9res"]), method="lambda", test=T)
phylosig(t1, pull(phyres2[match(t1$tip.label, phyres2$tip_taxa), "m12res"]), method="lambda", test=T)
# see no evidence for signal in residuals
```


### Cline by taxon

Do this analysis by taxon.

```{r}
xy1 <- xy[which(!xy$critter == "fish"),]
xy1 <- xy1[which(!xy1$critter == "other invertebrates"),]

t = split(xy1, xy1$critter)
taxares = data.frame(critter=names(t), 
                 num_studies=unlist(lapply(t, nrow)), 
                 best_model=rep(NA, length(t)), 
                 rsq=rep(NA, length(t)), 
                 dispersal=rep(NA, length(t)), 
                 mtDNA_dist=rep(NA, length(t)), 
                 interaction = rep(NA, length(t)),
                 dispersalRI =rep(NA, length(t)), 
                 mtDNA_distRI =rep(NA, length(t)), 
                 interactionRI = rep(NA, length(t)))

coefres = data.frame(critter = rep(NA, 2 * length(t)),
                     variable = rep(NA, 2 * length(t)),
                     coef = rep(NA, 2 * length(t)),
                     intercept = rep(NA, 2 * length(t)))

physig = vector('list', length(t))

for (i in 1:length(t)) {
  full_interaction = lm(log_width ~ log_dispersal_ind * log_dist, data = t[[i]])
  no_interaction = lm(log_width ~ log_dispersal_ind + log_dist, data = t[[i]])
  dispersal_only = lm(log_width ~ log_dispersal_ind, data = t[[i]])
  distance_only = lm(log_width ~ log_dist, data = t[[i]])
  intercept_only = lm(log_width ~ 1, data = t[[i]])
  ms <- list(full_interaction, no_interaction, dispersal_only, distance_only, intercept_only)
  names(ms) = c("full_interaction", "no_interaction", "dispersal_only", "distance_only", "intercept_only")
  
  res = summarize_lm(ms)
  best = which(as.numeric(res[[1]][, 3]) == min(as.numeric(res[[1]][, 3])))
  
  best_model = ms[[best]]
  coefbest = coef(best_model)
  coefres[2 * i - 1, 'critter'] = names(t)[i]
  coefres[2 * i, 'critter'] = names(t)[i]
  coefres[2 * i - 1, 'intercept'] = coef(best_model)[1]
  coefres[2 * i, 'intercept'] = coef(best_model)[1]
  coefres[2 * i - 1, 'variable'] = 'log_dist'
  coefres[2 * i, 'variable'] = 'log_dispersal_ind'
  if (length(which(names(coefbest) == "log_dist")) > 0) {
    coefres[2 * i - 1, 'coef'] = coefbest[which(names(coefbest) == "log_dist")]
  }
  if (length(which(names(coefbest) == "log_dispersal_ind")) > 0) {
    coefres[2 * i, 'coef'] = coefbest[which(names(coefbest) == "log_dispersal_ind")]
  }
  se_combine <- function(x) {
    return(paste(x[1], " (SE=", x[2], ")", sep=""))
  }
  
  taxares[i , "best_model"] = res[[1]][best, 1]
  taxares[i , "rsq"] = res[[1]][best, 4]
  taxares[i , "dispersal"] = se_combine(round(res[[2]][2, c(2,3)], 2))
  taxares[i , "mtDNA_dist"] = se_combine(round(res[[2]][3, c(2,3)], 2))
  taxares[i , "interaction"] = se_combine(round(res[[2]][4, c(2,3)], 2))
  taxares[i , "dispersalRI"] = round(res[[3]][1, 1], 3)
  taxares[i , "mtDNA_distRI"] = round(res[[3]][2, 1], 3)
  taxares[i , "interactionRI"] = round(res[[3]][3, 1], 3)

  # test phy signal
  phyres = cbind(t[[i]], res = best_model$residuals)
  phyres$tip_taxa = tips[match(phyres$Taxon1, tips$X), "tip_taxa"]
  t2 = drop.tip(t1, setdiff(t1$tip.label, phyres$tip_taxa))
  phyres1 = phyres[phyres$tip_taxa %in% t1$tip.label, ]
  # have multiple studies to the same tip, for now, just average residuals
  phyres2 = phyres1 %>% group_by(tip_taxa) %>% 
              summarise(res = mean(res)) %>% ungroup()
  physig[[i]] = phylosig(t2, pull(phyres2[match(t2$tip.label, phyres2$tip_taxa), "res"]),
           method="lambda", test = T)
}

knitr::kable(taxares)
write.csv(taxares, paste(outdir, "taxon_results.csv", sep=""), row.names = T)
```

Well, this is interesting. When we divide things up by critter, not analyzing fish separately because there are too few data points, the results are idiosyncratic across clades. Why don't we see the predicted pattern for mtDNA distance in the "all-clades" analyses? Maybe because birds & mammals are showing the opposite pattern of what we would expect, where greater mtDNA distances are positively correlated with cline width. NAR show cleanest match to predictions of tension zone model. 

```{r fig.width = 7, fig.asp = .7}
coefres1 = coefres[coefres$variable  == 'log_dispersal_ind', ]
coefres2 = coefres[coefres$variable  == 'log_dist', ]
a = ggplot(xy1, aes(log_dispersal_ind, log_width)) + geom_point(alpha=0.5, size = 0.7) + xlab("log(dispersal)") + ylab("log(cline width)")  + facet_wrap(~critter, ncol = 5) + geom_abline(data = coefres1, aes(intercept = intercept, slope = coef))
b = ggplot(xy1, aes(log_dist, log_width)) + geom_point(alpha=0.5, size = 0.7) + xlab("log(mtDNA distance)") + ylab("log(cline width)")  + facet_wrap(~critter, ncol = 5) +  geom_abline(data = coefres2, aes(intercept = intercept, slope = coef))

plt3 = plot_grid(a, b, nrow = 2, labels=c("A", "B"))
save_plot(paste(outdir, "by_taxon.png", sep=""), plt3, base_width = 10, base_height = 5)
```

## Supplementary Analyses

### Bird analyses

#### HWI as estimate of dispersal
Note that dispersal model only for birds has already been done above. Similar analysis to above using log HWI instead of dispersal distance. Slightly different set (n = 37 hybrid zones).

```{r}
HWI = aggregate(x$width, by=list(x$SystemID, x$critter, x$log_dist, x$log_HWI), gm_mean)
names(HWI) = c("SystemID", "critter", "log_dist", "log_HWI", "width")
HWI$log_width = log(HWI$width)

m1_HWI = lm(log_width ~ log_HWI * log_dist, data= HWI)
m2_HWI = lm(log_width ~ log_HWI + log_dist, data= HWI)
m3_HWI = lm(log_width ~ log_HWI, data= HWI)
m4_HWI = lm(log_width ~ log_dist, data= HWI)
m5_HWI = lm(log_width ~ 1, data = HWI)

AICc(m1_HWI, m2_HWI, m3_HWI, m4_HWI, m5_HWI)
HWI_models <- list(m1_HWI, m2_HWI, m3_HWI, m4_HWI, m5_HWI)

res = summarize_lm(HWI_models)
write.csv(res[[1]], paste(outdir, "birdHWI_model_fit1.csv", sep=""), row.names = F)
write.csv(res[[2]], paste(outdir, "birdHWI_model_fit2.csv", sep=""), row.names = F)
write.csv(res[[3]], paste(outdir, "birdHWI_model_fit3.csv", sep=""), row.names = T)
```
In HWI models, the HWI-only model is the preferred model by AIC, but just barely better than the HWI + mtDNA distance model. Again though, the residuals show the unexpected pattern, with the relationship opposite that expected by tension zone.

```{r fig.width = 7, fig.asp = .62}
a = ggplot(HWI, aes(log_HWI, log_width)) + geom_point(pch=21, fill = "black") + xlab("log(HWI)") + ylab("log(cline width)")
b = ggplot(HWI, aes(log_dist, log_width)) + geom_point(pch=21, fill = "black") + xlab("log(mtDNA dist)") + ylab("log(cline width)")
ab = plot_grid(a, b, labels = c("A", "B"), nrow = 1, align = "h")
save_plot(paste(outdir, 'bird_HWI.png', sep=""), ab, ncol = 2, nrow = 1, base_aspect_ratio = 1.3, base_width = 4)
```

```{r fig.width = 7, fig.asp = .62}
# the model with just dispersal is m3_HWI
HWI$residuals = residuals(m3_HWI)
ggplot(HWI, aes(log_dist, residuals)) + geom_point(pch=21, fill = "black") + xlab("log(mtDNA dist)") + ylab("residuals")
```

#### Div times as estimate of mtDNA dist

Burleigh divergence time analyses should have n = 17 (18 Burleigh divergence times, but Manacus has no dispersal data)

```{r}
bird_burl_dt = aggregate(x$width, by=list(x$SystemID, x$critter, x$div_time_Burleigh, x$log_dispersal), gm_mean)
names(bird_burl_dt) = c("SystemID", "critter", "Burleigh_dt", "log_disp", "width")
bird_burl_dt$Burleigh_dt = scale(log(bird_burl_dt$Burleigh_dt))
bird_burl_dt$log_width <- log(bird_burl_dt$width)

m1_Burl = lm(log_width ~ log_disp * Burleigh_dt, data= bird_burl_dt)
m2_Burl = lm(log_width ~ log_disp + Burleigh_dt, data= bird_burl_dt)
m3_Burl = lm(log_width ~ log_disp, data= bird_burl_dt)
m4_Burl = lm(log_width ~ Burleigh_dt, data= bird_burl_dt)
m5_Burl = lm(log_width ~ 1, data = bird_burl_dt)

Burl_models <- list(m1_Burl, m2_Burl, m3_Burl, m4_Burl, m5_Burl)
res_burl = summarize_lm(Burl_models)
Burl_averaged_model = model.avg(Burl_models)

Burl_pred_log_disp <- seq(from = -1.5, to = 2.3, length.out = 100)
Burl_pred_dt <- rep(0, 100)
newdata <- data.frame(Burl_pred_log_disp, Burl_pred_dt)
colnames(newdata) <- c("log_disp", "Burleigh_dt")

newdata$Burl_disp_preds <- predict(object = Burl_averaged_model, newdata = newdata, full = TRUE)

bird_burl_dt_with_outlier <- bird_burl_dt
bird_burl_dt_with_outlier$outlier = rep(FALSE, nrow(bird_burl_dt_with_outlier))
bird_burl_dt_with_outlier[which(bird_burl_dt$SystemID == 125), "outlier"] = TRUE
 
##Sula is an outlier. Removed.
bird_burl_dt <- bird_burl_dt[which(bird_burl_dt$SystemID != 125),]

m1_Burl_no_Sula = lm(log_width ~ log_disp * Burleigh_dt, data= bird_burl_dt)
m2_Burl_no_Sula = lm(log_width ~ log_disp + Burleigh_dt, data= bird_burl_dt)
m3_Burl_no_Sula = lm(log_width ~ log_disp, data= bird_burl_dt)
m4_Burl_no_Sula = lm(log_width ~ Burleigh_dt, data= bird_burl_dt)
m5_Burl_no_Sula = lm(log_width ~ 1, data = bird_burl_dt)

Burl_models_no_Sula <- list(m1_Burl_no_Sula, m2_Burl_no_Sula, m3_Burl_no_Sula, m4_Burl_no_Sula, m5_Burl_no_Sula)
Burl_averaged_model_no_Sula = model.avg(Burl_models_no_Sula)
res_noSula = summarize_lm(Burl_models_no_Sula)
  
newdata$Burl_disp_preds_no_Sula <- predict(object = Burl_averaged_model_no_Sula, newdata = newdata, full = FALSE)

reg_line_with_outlier <- lm(Burl_disp_preds ~ log_disp, data = newdata)
reg_line_no_outlier <- lm(Burl_disp_preds_no_Sula ~ log_disp, data = newdata)

a = ggplot(bird_burl_dt_with_outlier, aes(log_disp, log_width)) + geom_point(aes(color = outlier), size = 2.5)  + xlab("log dispersal") + ylab("log hybrid zone width")  + scale_color_manual(values=c("black", "red")) + theme(legend.position="none") + geom_abline(intercept = reg_line_with_outlier$coefficients[[1]], slope = reg_line_with_outlier$coefficients[[2]]) + geom_abline(intercept = reg_line_no_outlier$coefficients[[1]], slope = reg_line_no_outlier$coefficients[[2]], linetype = 3)

dt_vect <- (seq(from = -1.5, to = 1.75, length.out = 100))
Burl_pred_dt <- c(dt_vect, dt_vect, dt_vect)
Burl_pred_log_disp <- c(rep(-1,100), rep(0, 100), rep(1, 100))
newdata <- data.frame(Burl_pred_log_disp, Burl_pred_dt)
colnames(newdata) <- c("log_disp", "Burleigh_dt")

newdata$Burl_disp_preds <- predict(object = Burl_averaged_model, newdata = newdata, full = TRUE)
dt_line0 <- lm(Burl_disp_preds ~ Burleigh_dt, data = newdata[101:200,])
# dt_lineneg1 <- lm(Burl_disp_preds ~ Burleigh_dt, data = newdata[1:100,])
# dt_line1 <- lm(Burl_disp_preds ~ Burleigh_dt, data = newdata[201:300,])

b = ggplot(bird_burl_dt, aes(Burleigh_dt, log_width)) + geom_point(size = 2.5) + xlab("log divergence time") + ylab("log hybrid zone width") + geom_abline(intercept = dt_line0$coefficients[[1]], slope = dt_line0$coefficients[[2]])# + geom_abline(intercept = dt_lineneg1$coefficients[[1]], slope = dt_lineneg1$coefficients[[2]], color = "blue") + geom_abline(intercept = dt_line1$coefficients[[1]], slope = dt_line1$coefficients[[2]], color = "orange")
ab = plot_grid(a, b, labels = c("A", "B"), nrow = 1, align = "h")
save_plot(paste(outdir, "burleigh_pairs.png" , sep=""), ab, ncol = 2, nrow = 1, base_aspect_ratio = 1.3, base_width = 5)

write.csv(res_noSula[[1]], paste(outdir, "birdDiv_model_fit1.csv", sep=""), row.names = F)
write.csv(res_noSula[[2]], paste(outdir, "birdDiv_model_fit2.csv", sep=""), row.names = F)
write.csv(res_noSula[[3]], paste(outdir, "birdDiv_model_fit3.csv", sep=""), row.names = T)
```

```{r}
ggplot(xc, aes(critter, log_dispersal)) + geom_boxplot() + xlab("taxa") + ylab("log(dispersal)") + coord_flip()
ggplot(xc, aes(critter, log_dist)) + geom_boxplot() + xlab("taxa") + ylab("log(mtDNA distance)") + coord_flip()
ggplot(xc, aes(critter, log_width)) + geom_boxplot() + xlab("taxa") + ylab("log(cline width)") + coord_flip()
```


### Use only common mtDNA genes

What if some of our failure to explain things is because we are using so many genes to estimate genetic distance?

```{r}
g = xc[xc$mtDNA_genes == "cytb", ]

g1 = lmer(log_width ~ log_dispersal * log_dist + (1 | type) + (1 | critter / SystemID / TransectID), g)
g2 = lmer(log_width ~ log_dispersal + log_dist  + (1 | type) + (1 | critter / SystemID / TransectID), g)
g3 = lmer(log_width ~ log_dispersal + (1 | type) + (1 | critter /  SystemID / TransectID), g)
g4 = lmer(log_width ~ log_dist + (1 | type) + (1 |critter /  SystemID / TransectID), g)
g5 = lmer(log_width ~ 1 + (1 | type) + (1 |critter /  SystemID / TransectID), g)

models1 <- list(g1, g2, g3, g4, g5)
res = summarize_model(models1)

write.csv(res[[1]], paste(outdir, "most_mtDNA_model_fit1.csv", sep=""), row.names = F)
write.csv(res[[2]], paste(outdir, "most_mtDNA_model_fit2.csv", sep=""), row.names = T)
write.csv(res[[3]], paste(outdir, "most_mtDNA_model_fit3.csv", sep=""), row.names = T)

```


### Outlier plot 
```{r}
xy = aggregate(x$width, by=list(x$SystemID, x$critter, x$mean_dist, x$dispersal), gm_mean)
names(xy) = c("SystemID", "critter", "dist", "dispersal", "width")

xy$outlier = rep("not", nrow(xy))

exp_width <- function(s, sigma) {
  return(sqrt(8) * sigma /sqrt(s))
}

xy[xy$width < sapply(xy$dispersal, exp_width, s = 0.5), 'outlier'] = 'low'
xy[xy$width > sapply(xy$dispersal, exp_width, s = 0.0001), 'outlier'] = 'high'

outliers = ggplot(xy, aes(dispersal, width)) + 
  geom_point(shape = 21, size = 2, alpha = 0.8, fill = "gray") + 
  scale_x_log10() + scale_y_log10() + 
  geom_abline(slope = 1, intercept = log10(sqrt(8)) + log10(1  / sqrt(0.5))) + 
  geom_abline(slope = 1, intercept = log10(sqrt(8)) + log10(1 / sqrt(0.0001))) +  
  geom_abline(slope = 1, intercept = log10(sqrt(8)) + log10(1 / sqrt(0.0001))) +
  theme(legend.position="none")
save_plot(paste(outdir, 'outlier.png', sep=""), outliers,
          ncol = 1, nrow = 1, base_height = 3, base_aspect_ratio = 1.2
)
```

## Barton model analyses
### Cline width variance

Look at predictors of cline width variance by mtDNA dist & dispersal for those contact zones where multiple clines were measured, all clines

```{r}
cv <- function(vec) { return(sd(vec, na.rm=TRUE) / mean(vec, na.rm=TRUE)) }

cmean = aggregate(x$width, by=list(x$SystemID), mean)
cvar = aggregate(x$width, by=list(x$SystemID, x$critter, x$log_dist, x$log_dispersal), sd)
names(cvar) = c("SystemID", "critter", "log_dist", "log_dispersal", "sd")
cvar = cvar[complete.cases(cvar$sd), ]
cvar$cv = cvar$sd / cmean[match(cvar$SystemID, cmean$Group.1), "x"]
cts = table(x$SystemID)
cvar$num_clines = cts[match(cvar$SystemID, names(cts))]

cvar$log_sd = log(cvar$sd)
cvar$log_cv = log(cvar$cv)
cvar = cvar[is.finite(cvar$log_cv), ]

cvar1 = cvar[cvar$sd > 0, ]
sd1 = lm(log_sd ~ log_dist + log_dispersal + critter, data = cvar1)
sd2 = lm(log_sd ~ log_dist + critter, data = cvar1)
sd3 = lm(log_sd ~ log_dispersal + critter, data = cvar1)
sd4 = lm(log_sd ~ log_dist + log_dispersal, data = cvar1)
sd5 = lm(log_sd ~ log_dispersal, data = cvar1)
sd6 = lm(log_sd ~ log_dist, data = cvar1)
mods = list(sd1, sd2, sd3, sd4, sd5, sd6)
summarize_lm(mods)

a = ggplot(cvar1, aes(log_dist, log_sd)) + geom_point() + xlab("log(mtDNA distance)") + ylab("st. dev. of cline width")
save_plot(paste(outdir, "barton_prediction.png" , sep=""), a, base_height = 3, base_width = 4)
 
cv1 = lm(cvar$log_cv ~ cvar$log_dist + cvar$log_dispersal + cvar$critter)
cv2 = lm(cvar$log_cv ~ cvar$log_dist + cvar$critter)
cv3 = lm(cvar$log_cv ~ cvar$critter + cvar$log_dispersal)
```

The only thing that predicts s.d. of cline width is dispersal, with greater dispersal leading to greater s.d. But, we see no pattern in coefficient of variation, which controls for difference in mean cline width.

```{r fig.width = 7, fig.asp = .7}
ggplot(cvar, aes(log_dispersal, log_sd)) + geom_point(pch=21, aes(fill=critter)) + xlab("log(dispersal)") + ylab("sd of cline width")
ggplot(cvar, aes(log_dist, log_sd)) + geom_point(pch=21, aes(fill=critter)) + xlab("log(mtDNA dist)") + ylab("sd of cline width")
ggplot(cvar, aes(log_dispersal, log_cv)) + geom_point(pch=21, aes(fill=critter)) + xlab("log(dispersal)") + ylab("cv of cline width")
ggplot(cvar, aes(log_dist, log_cv)) + geom_point(pch=21, aes(fill=critter)) + xlab("log(mtDNA dist)") + ylab("cv of cline width")
```


### Selection Strength

Measure selection strength for each cline using Barton equation -- see how that correlates to mtDNA dist across clines

```{r}
sel = aggregate(x$width, by=list(x$SystemID, x$critter, x$log_dist, x$log_dispersal, x$dispersal), gm_mean)
names(sel) = c("SystemID", "critter", "log_dist", "log_dispersal", "dispersal", "width")
sel$selection = 8 * (sel$dispersal / sel$width) ^ 2
```

First thing to note is that there are a number of systems where selection against heterozygotes is greater than 1! 

```{r}
ggplot(sel, aes(selection)) + geom_histogram(binwidth=0.25) + scale_x_log10() + xlab("selection strength") + geom_vline(xintercept=1, colour="red")
```

This is biologically impossible, and likely reflects over-estimates of dispersal rates. It could also reflect that this equation breaks down at higher selection strengths.

```{r}
sel$Taxon1 = x[match(sel$SystemID, x$SystemID), "Taxon1"]
sel$Taxon2 = x[match(sel$SystemID, x$SystemID), "Taxon2"]
sel$critter = x[match(sel$SystemID, x$SystemID), "critter"]

knitr::kable(sel[sel$selection > 1, c("Taxon1", "critter", "dispersal", "width", "selection")])
```

The main pattern that I see is that birds appear over-represented. Don't know what we should do with this information. _Eunicea flexuosa_ is again a huge outlier.

```{r fig.width = 7, fig.asp = .62}
sel2 = sel[sel$selection < 10000,]
sel_m = lm(log(sel2$selection) ~ sel2$log_dist)
ggplot(sel, aes(log_dist, selection)) + geom_point(pch=21, aes(fill=critter)) + scale_y_log10() + xlab("log(mtDNA distance)") + facet_wrap(~critter)
```

No pattern except for in NAR.